# 闭包

## 什么是闭包？

- 《高级程序设计》的定义:
闭包是指有权访问**另一个函数作用域中的变量**的**函数**。

- 《维基百科》的定义： 
    链接地址:  
    [维基百科：闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))

   闭包在实现上是一个结构体，它**存储了一个函数**（通常是其入口地址）和**一个关联的环境**（相当于一个符号查找表）-->包含非本函数的局部变量所在的执行环境。

- MDN的定义：  
[MDN web docs-闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures) 

    函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，**闭包可以让你从内部函数访问外部函数作用域。** **在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。**(存在疑问？？？)

## 为什么叫闭包？闭包的由来
  - 个人理解：每个函数都有自己封闭的函数作用域，但在该封闭作用域内包含引用了其他函数的变量，所以这就是闭包-封闭（自身作用域）和包含（其它函数的变量）。通常情况下，一个函数要引用其他函数的变量，该函数为其引用变量函数的子函数，这样才能正常访问其他函数的变量。


  闭包的由来：  


##  闭包的表现形式
如果函数A内定义了函数B，那么如果B存在自由变量，且这些自由变量（在函数外部定义但在函数内被引用）没有在编译过程B中被优化掉，那么将产生闭包。
    
    
个人理解：
- **一个函数A执行的时候可以拿到另一个函数B的局部变量，这就是闭包。不管A和B是否存在嵌套关系。**(增加最后一句话是因为自己曾经存在的误区)
- 一个函数A引用了另一个函数B的局部变量，函数A在被调用时肯定会形成闭包。闭包在函数执行时产生。

示例：  
```
function createComparisonFunction(propertyName) {
    return function (object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        debugger;
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    }
}

var compareNames = createComparisonFunction("name");

var result = compareNames({
    name: "Jackson Yee"
}, {
    name: "易烊千玺"
});

compareNames = null; // 解除对匿名函数的引用，以便释放内存
```
例子中匿名函数之所以还能访问这个变量，是因为内部函数的作用链中包含createComparisonFunction()的作用域。  
某个函数被调用时，会创建一个执行环境（execution context）及相应的作用链。然后，使用arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动处于第三位，......直至作为作用域终点的全局执行环境。
当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名被销毁后，createComparisonFunction()的活动对象才会被销毁。  
首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null 解除该函数的引用，就等于通过垃圾回收历程将其清除。



## 闭包与变量  
作用域链的配置机制会引出一个值得注意的副作用，即闭包**只能取得包含函数中任何变量（即该函数引用其它函数的变量）的最后一个值**。因为闭包保存的是整个变量对象（引用变量函数的作用域），而不是某个特殊的变量。  

重点：只会取得引用变量的最后一个值、闭包保存的是整个变量对象而不是某个特殊变量。  
>引申：变量对象  
  
    变量对象：执行环境中定义的所有的变量和函数都会保存在一个对象中，保存的这个对象就叫变量对象。  

    执行环境：函数在执行时形成的环境。每个函数都有自己的执行环境，每个执行环境都有一个与之关联的对象。全局执行环境是最外围的执行环境。

    作用域链：当代码在一个环境中执行时，会创建变量对象的作用域链。作用域链本质上是一个 指向变量对象的指针列表 ，它 引用但不实际包含变量对象 。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。全局执行环境的变量对象始终是作用域链中最后一个对象。



## 常见使用闭包的场景
- 模仿块级作用域
- 保护私有变量
  - 什么是私有变量?  
    XXXXXXXXX
- 模块模式
  - 什么是模块模式?   
    XXXXXXXXXXXXX

## 闭包导致的问题
1.内存泄漏：  
- 什么是内存泄露？
  - 百度百科的定义：
    内存泄漏（Mermery Lake）是指程序中动态分配由于某种原因程序未释放或无法释放，**造成系统的浪费**，导致程序运行的速度减慢甚至崩溃等严重后果。

  个人通俗理解：闭包的形成占用了更多的内存空间，导致变量可用的空间减少，就像是内存泄漏了一样，所以就内存泄漏。


  解决内存泄漏的方式：  
    -  将保存闭包的变量的值设置为null








