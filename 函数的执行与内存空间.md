闭包示例：
``` javascript
function createIncrement(i) {
    let value = 0;

    function increment() {
        value += i;
        console.log(value)
        const message = `Current value is ${value}`
        return function logValue() {
            console.log(message)
        }
    }
    return increment
}

const inc = createIncrement(10)

const log = inc() ; // 10

inc() // 20
inc() // 30

log() // "Current value is 10"

```

这是一个典型的闭包的例子，本篇文章将从函数的执行与内存空间占用的角度去解释函数执行后的打印结果。

# 内容
## 1.预编译
- 1.1 js执行的三个步骤
- 1.2 预编译的两个现象
- 1.3 预编译的四个步骤
## 2.函数相关
- 2.1 引用类型
- 2.2 函数的执行与内存空间
## 3.函数执行与闭包

# 预编译
js 运行三部曲：   
1.词法分析   
2.预编译   
3.解释执行

js的特点：单线程的解释性语言，解释性语言通俗来说就是翻译一句执行一句  

词法分析：  
- 语法分析或者语义分析，**通篇扫描一遍看是否存在低级的语法错误**，但不会执行，通篇扫描的过程就是语法分析的过程。

预编译：  
为什么要知道预编译？  
包含了声明提前的过程。

- 前提：  
    - 暗示全局任何变量，如果未经声明就赋值，此变量为全局对象所有。
    - 一切声明的全局变量，全是window的属性。

- 预编译的两个现象：
    - 函数声明 **整体提升**
    - 变量  **声明提升**（不会变量值，只是提升声明），因此在任何位置都可以调用函数，但若要使用变量的值，需等执行到赋值语句才可以。

- 预编译的四个步骤：
    - 1.创建AO（active object）对象
    - 2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined
    - 3.将实参和形参统一
    - 4.在函数体里面找到函数声明，值赋予函数体


解释执行：   
- 解释一行，执行一行


## 函数

- 引用类型
- 函数的执行与内存空间

### 1.引用类型

- 什么是类型？  
   引用类型是指那些可能由 **多个值** 构成的 **对象** 。

- 引用类型的特点：  
   ![引用类型的复制]('./images/引用类型.jpg')

  1、引用类型的变量名是一个保存引用地址的指针，不会与某个对象绑定。函数属于引用类型中的一种，那么函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。  
   不会与某个对象绑定：指的是引用类型的对象名、数组名、函数名和其它变量是一样的，都是保存在栈内存中的变量，对象名称本身不是对象，只是一个指针。

  2、引用类型复制时，会将栈内存中的引用地址（对象名）复制一份放到为新变量分配的空间中，复制后的新变量仍然和旧变量指向堆内存中的同一个对象。

  3、当复制保存着的变量时，操作的是对象的引用。但在对 对象进行操作（增、删、改）时，操作的是实际的对象。

### 2.函数的执行和内存空间

函数的[[scopes]]：

```
function compare(value1, value2) {
    console.log(value1,value2);
}

console.dir(compare);
```

打印结果如图：  
![函数创建]('./images/函数创建.png')

根据打印结果可以看到，函数创建之后，函数作用域链[[scopes]]已经存在，只是此时作用链中只有全局的变量对象。

[[scopes]]：保存某个函数作用域链的对象。根据引用类型的特点，作用域链本质上是一个指向变量的 **指针列表** ，它只引用但不实际包含变量对象。

[[scopes]]不能根据对象访问属性的方式直接访问，通过 compare.[[scopes]] 形式进行访问会直接报错。

函数不能直接访问高亮属性，可访问非高亮属性  
![函数属性访问]('./images/函数属性访问.png')  


**函数的执行和内存空间**:   
  对上个例子中compare函数进行调用 compare(1,2) ,会经历如下步骤：

    1.为函数创建一个执行环境  

    2.复制函数[[scopes]]属性中的对象构建起执行环境的作用域链

    3.创建函数活动对象并推入执行环境作用域的前端  

    4.执行代码  

    5.销毁执行环境和活动对象（闭包情况下活动对象可能仍被引用没被销毁）

![函数执行]('./images/函数执行.png')


